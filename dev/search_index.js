var documenterSearchIndex = {"docs":
[{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = BioRecordsProcessing\n\nDocTestSetup = quote\n    using BioRecordsProcessing, FASTX, BioSequences\n    \n    dir = mktempdir()\n    filepath = joinpath(dir, \"test_1.fa\")\n\n    seq = [\n        \"CTTGGCATACTCAAACTCTT\",\n        \"TGGCATACTCACTAACTCTT\",\n    ]\n    writer = open(FASTA.Writer, filepath)\n    for i=1:2\n        write(writer, FASTA.Record(\"seq$i\", seq[i]))\n    end\n    close(writer)\n\n    filepath2 = joinpath(dir, \"test_2.fa\")\n    seq = [\n        \"GCAAACTCTTCTTGGCATAC\",\n        \"ATACTCAAACTCTTCTTGGC\",\n    ]\n    writer = open(FASTA.Writer, filepath2)\n    for i=1:2\n        write(writer, FASTA.Record(\"seq$i\", seq[i]))\n    end\n    close(writer)\nend\n\n# filter out temporary folder\nDocTestFilters = [\n    r\"Process\\(.*\",\n    r\"/var/folders.*\",\n    r\" \\\"/var/folders.*\",\n    r\"/tmp/.*\",\n    r\" \\\"/tmp/.*\",\n]","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"All examples use FASTA files but should work with FASTQ, compressed .gz files, VCF from  VariantCallFormat.jl and XAM.jl types. More examples can be found in the tests.","category":"page"},{"location":"examples/#Reading-a-FASTA-file-into-memory","page":"Examples","title":"Reading a FASTA file into memory","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using BioRecordsProcessing, FASTX, BioSequences\n\n# the file contains two 20bp reads\np = Pipeline(\n    Reader(FASTX.FASTA, File(filepath)),\n    record -> begin\n        sequence(LongDNA{4}, record)\n    end,\n    Collect(LongDNA{4}),\n)\nrun(p)\n\n# output\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n CTTGGCATACTCAAACTCTT\n TGGCATACTCACTAACTCTT","category":"page"},{"location":"examples/#Transforming-a-FASTA-file","page":"Examples","title":"Transforming a FASTA file","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using BioRecordsProcessing, FASTX, BioSequences\n\n# the file contains two 20bp reads, trim first 10bp\np = Pipeline(\n    Reader(FASTX.FASTA, File(filepath)),\n    record -> begin\n        seq = sequence(LongDNA{4}, record)\n        FASTA.Record(FASTA.identifier(record), seq[10:end])\n    end,\n    Writer(FASTX.FASTA, dir; suffix = \".trimmed\"),\n)\nout = run(p)\nrun(`head $out`)\n\n# output\n>seq1\nCTCAAACTCTT\n>seq2\nCACTAACTCTT\nProcess(`head /var/folders/8g/xj7pzy251n53px06l17vr0_00000gr/T/jl_mL4pM7/test_1.trimmed.fa`, ProcessExited(0))","category":"page"},{"location":"examples/#Reading-a-pair-of-FASTA-file","page":"Examples","title":"Reading a pair of FASTA file","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using BioRecordsProcessing, FASTX, BioSequences\n\n# first in pair is named \"_1.fasta\", second \"_2.fasta\"\np = Pipeline(\n    Reader(FASTX.FASTA, File(filepath; second_in_pair = x -> replace(x, \"_1\" => \"_2\"))),\n    (r1, r2) -> begin\n        sequence(LongDNA{4}, r1), sequence(LongDNA{4}, r2)\n    end,\n    Collect(LongDNA{4}; paired = true),\n)\nrun(p)\n\n# output\n2-element Vector{Tuple{LongSequence{DNAAlphabet{4}}, LongSequence{DNAAlphabet{4}}}}:\n (CTTGGCATACTCAAACTCTT, GCAAACTCTTCTTGGCATAC)\n (TGGCATACTCACTAACTCTT, ATACTCAAACTCTTCTTGGC)","category":"page"},{"location":"examples/#Processing-all-files-in-a-directory","page":"Examples","title":"Processing all files in a directory","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using BioRecordsProcessing, FASTX, BioSequences\n\n\np = Pipeline(\n    Reader(FASTX.FASTA, Directory(dir, \"*.fa\")),\n    record -> begin\n        seq = sequence(LongDNA{4}, record)\n        FASTA.Record(FASTA.identifier(record), seq[10:end])\n    end,\n    Writer(FASTX.FASTA, dir; suffix = \".trimmed\"),\n)\nout = run(p; verbose = false)\nbasename.(out)# run returns the path to output files\n\n# output\n2-element Vector{String}:\n \"test_1.trimmed.fa\"\n \"test_2.trimmed.fa\"","category":"page"},{"location":"examples/#Write-sequences-in-memory-into-a-file","page":"Examples","title":"Write sequences in memory into a file","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using BioRecordsProcessing, FASTX, BioSequences\n\ndata = [FASTA.Record(\"seq1\", dna\"ATGC\")]\n\np = Pipeline(\n    Buffer(data; filename = \"test.fa\"),\n    Writer(FASTX.FASTA, dir),\n)\nout = run(p)\nrun(`head $out`)\n\n# output\n>seq1\nATGC\nProcess(`head /var/folders/8g/xj7pzy251n53px06l17vr0_00000gr/T/jl_NSdfEq/test.fa`, ProcessExited(0))","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"CurrentModule = BioRecordsProcessing\n\nDocTestSetup = quote\n    using BioRecordsProcessing, FASTX, BioSequences\n    \n    dir = mktempdir()\n    filepath = joinpath(dir, \"test.fa\")\n\n    seq = [\n        \"CTTGGCATACTCAAACTCTT\",\n        \"CTTGGCATACTCAAACTCTT\",\n    ]\n    writer = open(FASTA.Writer, filepath)\n    for i=1:2\n        write(writer, FASTA.Record(\"seq$i\", seq[i]))\n    end\n    close(writer)\nend","category":"page"},{"location":"#BioRecordsProcessing","page":"Manual","title":"BioRecordsProcessing","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"In BioRecordsProcessing records are processed using a Pipeline that is constructed by taking a source (producing records), a user-defined function to process the records and a sink that will store the output of the processing function. The pipeline can then be run.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In this example a FASTA file is read from the disk, the sequence is extracted from the records and collected in an array :","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"using BioRecordsProcessing, FASTX, BioSequences\n\np = Pipeline(\n    Reader(FASTX.FASTA, File(filepath)),\n    record -> begin\n        sequence(LongDNA{4}, record)\n    end,\n    Collect(LongDNA{4}),\n)\nrun(p)\n\n# output\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n CTTGGCATACTCAAACTCTT\n CTTGGCATACTCAAACTCTT","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"By using different combinations of source and sink, and with user defined processing function, this allows to handle many common cases of biological records processing.","category":"page"},{"location":"#Conventions","page":"Manual","title":"Conventions","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"If the processing function returns nothing the record will not be written to the sink, allowing to filter out records.\nWhen writing a file to the disk the sink will get the filename from the source, so a source need to have a filename provided in this case.\nPaired records are passed as a tuple to the processing function, and this function should generally returns a tuple of records.","category":"page"},{"location":"#Sources","page":"Manual","title":"Sources","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"BioRecordsProcessing.Reader\nBioRecordsProcessing.Buffer","category":"page"},{"location":"#BioRecordsProcessing.Reader","page":"Manual","title":"BioRecordsProcessing.Reader","text":"Reader(record_module::Module, file_provider::F) where {F <: AbstractFileProvider}\n\nRead a file or a directory on the disk and produce records of type record_module.Record.  The second argument can be a File or a Directory.\n\nIf a string is passed the second argment will default to File.\n\nReader(FASTX.FASTA, \"test.fa\")\nReader(FASTX.FASTA, File(\"test.fa\"))\nReader(FASTX.FASTQ, Directory(\"data/\", \"*.fastq\"))\n\n\n\n\n\n","category":"type"},{"location":"#BioRecordsProcessing.Buffer","page":"Manual","title":"BioRecordsProcessing.Buffer","text":"Buffer(data::Vector{T}; filename = \"\")\n\nUse the array data as a source of records. An optional filename can be provided when a Writer is used as a sink.\n\n\n\n\n\n","category":"type"},{"location":"#File-Providers","page":"Manual","title":"File Providers","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Reader can take one of these files provider as agument :","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"BioRecordsProcessing.File\nBioRecordsProcessing.Directory","category":"page"},{"location":"#BioRecordsProcessing.File","page":"Manual","title":"BioRecordsProcessing.File","text":"File(filename; second_in_pair = nothing)\n\nFor paired files a function taking as argument the filename of the first file in pair and returning the filename of the second file can be provided. For example one can use replace  or a dictionnary, e.g. second_in_pair = f1 -> replace(f1, \"_1\" => \"_2\").\n\n\n\n\n\n","category":"type"},{"location":"#BioRecordsProcessing.Directory","page":"Manual","title":"BioRecordsProcessing.Directory","text":"Directory(directory::String, glob_pattern::String; second_in_pair = nothing)\n\nList all files matching the glob_pattern (See Glob.jl) in directory. For paired files a function taking as argument the filename of the first file in pair and returning the filename of the second file can be provided.\n\nDirectory(input_directory, \"*.fastq\")\n\n\n\n\n\n","category":"type"},{"location":"#Sinks","page":"Manual","title":"Sinks","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Writer","category":"page"},{"location":"#BioRecordsProcessing.Writer","page":"Manual","title":"BioRecordsProcessing.Writer","text":"Writer(record_module::Module, output_directory::String; \n    suffix = \"\", \n    paired = false, \n    second_in_pair = nothing, \n    extension = nothing, \n    header = nothing\n)\n\nWrite the output of the processing function into a file, the first argument is the module that owns the Record type (e.g FASTX.FASTA, VCF, ...), and the second the ouput directory. The filename is determined by the source, to which an optional suffix can be added.  If the type ouput is different from the type of the output (e.g. SAM to BAM), the extension (\".bam\") should be specified. For SAM & BAM a SAM.Header should be provided.\n\nTo avoid overwriting existing files, the pipeline will check that the output file is different from the input file.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Manual","title":"Manual","text":"Collect","category":"page"},{"location":"#BioRecordsProcessing.Collect","page":"Manual","title":"BioRecordsProcessing.Collect","text":"Collect(T::DataType; paired=false)\n\nWrite the output of the processing function into an vector in memory. The type of output has to be provided. For paired files the option paired need to be set to true, the output will then consists of a vector of tuples.\n\n\n\n\n\n","category":"type"},{"location":"#Pipeline","page":"Manual","title":"Pipeline","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Pipeline\nrun","category":"page"},{"location":"#BioRecordsProcessing.Pipeline","page":"Manual","title":"BioRecordsProcessing.Pipeline","text":"Pipeline(source, processor, sink)\nPipeline(source, sink)\n\nBuild a Pipeline, if processor is omitted it will default to identity.\n\n\n\n\n\n","category":"type"},{"location":"#Base.run","page":"Manual","title":"Base.run","text":"run(p::Pipeline; max_records = Inf, verbose = true)\n\nRun the pipeline, the processing will stop after max_records have been read. Depending on the sink it will return a path to the output file or an array.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"-","title":"-","text":"","category":"page"},{"location":"API/","page":"-","title":"-","text":"#@autodocs #Modules = [BioRecordsProcessing] #","category":"page"}]
}
